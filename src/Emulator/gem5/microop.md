# microop in gem5

Take x86 `movl $4, %eax` for an example.
Depict how a macroop is translated to microops.

<div style="text-align:right; font-size:3em;">2022.06.25</div>

## microop definition

![](./pictures/microop.svg)

## macroop => microops

This chapter describes how
build/X86/arch/x86/generated/decoder-ns.cc.inc
is generated.
Code in decoder-ns.cc.inc decodes x86 macroop to microops during gem5 runtime.

### involved codes

src/arch/micro_asm.py:

```python
from insts import microcode
...
assembler = MicroAssembler(X86Macroop, microopClasses, mainRom, Rom_Macroop)
...
macroopDict = assembler.assemble(microcode)
```

src/arch/x86/isa/macroop.isa:

```python
class X86Macroop(Combinational_Macroop):
  ...
```

src/arch/x86/isa/microops/limmop.isa:

```python
class LimmOp(X86Microop):
  ...
  def getAllocator(self, microFlags):
    allocString = '''
      (%(dataSize)s >= 4) ?
        ...
    ...
    '''
microopClasses["limm"] = LimmOp
```

<div style="text-align:right; font-size:3em;">2022.06.23</div>

## fetch rom microop not impl

src/cpu/simple/base.cc:

```cpp
BaseSimpleCPU::preExecute() {
...
if (isRomMicroPC(pc_state.microPC())) {
  t_info.stayAtPC = false;
  /// fetchRomMicroop is not implemented yet!
  curStaticInst = decoder->fetchRomMicroop(pc_state.microPC(), curMacroStaticInst);
} else if (!curMacroStaticInst) {

} else {

}
...
}
```

## [TODO]decode cache

src/arch/x86/decoder.cc:

```cpp
Decoder::decode(ExtMachInst mach_inst, Addr addr) {
  ...
  auto iter = instMap->find(mach_inst);
  if (iter != instMap->end()) {
    /// if find mach_inst in instMap
    si = iter->second;
  } else {
    /// if not find mach_inst in instMap
    si = decodeInst(mach_inst);
    (*instMap)[mach_inst] = si;
  }
  ...
}
```

Function `decodeInst()`'s signature is

```cpp
StaticInstPtr X86ISA::Decoder::decodeInst(X86ISA::ExtMachInst machInst)
```

`decodeInst()` recieves `ExtMachInst`, outputs `StaticInstPtr`.

<details>
<summary>Class `StaticInst`'s heritage is interesting.</summary>
<img src="./pictures/classgem5_1_1StaticInst.png">
</details>

`StaticInst` seems to be the base class for every gem5 instructions in every architecture.
However, `X86StaticInst` is special, only has two derived class `MacroopBase` and `X86MicroopBase`.

`MacroopBase`'s derived classes are all generated by .isa file.

* `MacroopBase`
  * ./isa/macroop.isa => ./arch/x86/generated/decoder-ns.hh.inc:

    `Macroop`

    * ./build/X86/arch/x86/generated/decoder-ns.hh.inc:

      tons of `x86_macroop::` classes derives from `Macroop`

      * build/X86/arch/x86/generated/decoder.hh

        `x86_macroop::` is in namespace `X86ISAInst::`

`X86MicroopBase`'s derived class

<details>
<summary>`X86MicroopBase`'s derived class heritage</summary>
<img src="./pictures/classgem5_1_1X86ISA_1_1X86MicroopBase.png">
</details>

* src/arch/x86/insts/microregop.hh:

  `X86MicroopBase`

  * Becomes a template arg in `InstOperands`, alias as `RegOpT`

  ```cpp
  class RegOpBase : public X86MicroopBase {...};
  /// This is a C++11 syntax, called type alias or alias template, see cppreference.com
  template <typename ...Operands>
  using RegOpT = InstOperands<RegOpBase, Operands...>;
  ```

    * src/arch/x86/insts/microop_args.hh:

      `InstOperands` uses template parameter pack tricks quite a lot, see cppreference.com

    * src/arch/x86/isa/microops/{limmop.isa & regop.isa} => ./arch/x86/generated/decoder-ns.hh.inc:

      tons of classes class derives from `X86ISA::RegOpT`

      * build/X86/arch/x86/generated/decoder.hh

        all these classes is in namespace `X86ISAInst::`

