æƒ³æ‰¾å†å²ç‰ˆæœ¬çš„LLVMï¼Œå¯ä»¥çœ‹è¿™é‡Œhttp://releases.llvm.org/

2019.10.21çœ‹åˆ°ä¸€ä¸ªå¥½ç©çš„ï¼Œåœ¨è¿™ç¯‡æ–‡ç« çš„ç¬¬äºŒé¡µï¼ŒIntroductionéƒ¨åˆ†ï¼Œ

> Nevertheless, itâ€™s important to note that LLVM is **not** intended to be a universal compiler IR.

ç„¶è€Œåœ¨ä¸Šé¢é‚£ä¸ªç½‘ç«™çš„Introductionçš„éƒ¨åˆ†ï¼Œ

> It aims to be a "universal IR" of sorts, by being at a low enough level that high-level ideas may be cleanly mapped to it (similar to how microprocessors are "universal IR's", allowing many source languages to be mapped to them).

è¯´æ³•å®Œå…¨ç›¸åï¼Œå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆï¼<span style="font-size:1.5em;">ğŸ˜…ğŸ˜‚ğŸ¤£</span>

ABORT: 

* â€œæƒ³çŸ¥é“é™¤äº†SSA[^15]ï¼Œè¿˜æœ‰æ²¡æœ‰å…¶ä»–å½¢å¼ï¼Œè¿™æ ·æ‰èƒ½çŸ¥é“SSAä¸ºä»€ä¹ˆç”¨äºç¼–è¯‘å™¨ä¸­é—´è¡¨ç¤ºçš„ä¼˜åŠ¿å’ŒåŠ£åŠ¿ã€‚â€

<div style="font-size:3em; text-align:right;">2019.10.20</div>
# [LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation](../../../Essays/IR/2004.LLVM-A_Compilation_Framework_for_Lifelong_Program_Analysis_Transformation.pdf)é˜…è¯»ç¬”è®°

## ABSTRACT

## 1. INTRODUCTION

> Allowing lifelong lifelong reoptimization of the program gives architects the power to evolve processors and exposed interfaces in more flexible ways [^11] [^20], while allowing legacy applications to run well on new systems.

è¿™ä¸ªä¸å°±å’ŒäºŒè¿›åˆ¶ç¿»è¯‘çš„ç›®æ ‡ä¸€è‡´å˜›ï¼Œè¿™æ ·çœ‹æ¥è¿™ä¸ªLLVMæœ‰ç‚¹å‰å®³äº†ã€‚çœ‹å¼•ç”¨ç«Ÿç„¶å°±æ˜¯ä¸¤ä¸ªæœ‰åçš„äºŒè¿›åˆ¶ç¿»è¯‘ç³»ç»ŸFX!32å’ŒDAISYå˜›ï¼Œæœ‰ç©ºå¯ä»¥çœ‹çœ‹è¿™ä¸¤ç¯‡æ–‡ç« ã€‚

[^11]: A. Chernoff, et al. FX!32: A profile-directed binary translator. IEEE Micro, 18(2):56â€“64, 1998.
[^20]: K. Ebcioglu and E. R. Altman. DAISY: Dynamic compilation for 100% architectural compatibility. In ISCA, pages 26â€“37, 1997.
---

> This paper presents LLVM â€” Low-Level Virtual Machine â€” a compiler framework that aims to make lifelong program analysis and transformation available for arbitrary software, and in a manner that is transparent to programmers. LLVM achieves this through two parts: (a) ***a code representation* with several novel features that serves as a common representation for analysis, transformation, and code distribution**...

åŠ ç²—éƒ¨åˆ†ä¾¿æ˜¯æˆ‘è¿™æ¬¡è¯»è¿™ç¯‡æ–‡ç« çš„é‡ç‚¹å…³æ³¨ç‚¹ï¼

---

> Because of the differing goals and representations, LLVM is complementary to high-level virtual machines (e.g., Small Talk [18], Self [43], **JVM** [^32], Microsoftâ€™s CLI [33], and others), and not an alternative to these systems. It differs from these in three key ways. First, LLVM has no notion of high-level constructs such as classes, inheritance, or exception-handling semantics, even when compiling source languages with these features. Second, LLVM does not specify a runtime system or particular object model: it is low-level enough that the runtime system for a particular language can be implemented in LLVM itself. Indeed, LLVM can be used to implement high-level virtual machines. Third, LLVM does not guarantee type safety, memory safety, or language interoperability any more than the assembly language for a physical processor does.

å¾ˆå¥½å¥‡è¿™é‡Œä¸¾çš„ä¾‹å­åªè®¤è¯†JVMï¼Œä½†ä¸ºä»€ä¹ˆç§°JVMä¸ºhigh-level virtual machineså‘¢ï¼Ÿjavaä¸ä¹Ÿæ˜¯bytecodeå˜›ï¼Ÿå¥½æƒ³æœ‰æ—¶é—´å»äº†è§£äº†è§£å½“æ—¶çš„JAVAæ‰‹å†Œï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯1997å¹´ç‰ˆæœ¬çš„javaè™šæ‹Ÿæœºè¿˜æ²¡æœ‰bytecodeï¼Ÿæˆ–æ˜¯bytecodeç¡®å®æ˜¯é«˜çº§è¯­è¨€ï¼Ÿä¸è¿‡æœ€æ—©åªèƒ½çœ‹åˆ°2006å¹´çš„ç‰ˆæœ¬çš„å³java se6è§oracleå®˜ç½‘çš„[Java Language and Virtual Machine Specifications](https://docs.oracle.com/javase/specs/index.html)é¡µé¢ã€‚

[^32]: T. Lindholm and F. Yellin. The Java Virtual Machine Specification. Addison-Wesley, Reading, MA, 1997.

---

<div style="font-size:3em; text-align:right;">2019.10.21</div>
> We evaluate the effectiveness of the LLVM system with respect to three issues: (a) the size and effectiveness of the representation, including the ability to extract useful type information for C programs;

æåˆ°äº†æœ¬æ–‡å°†è¦è®²ä¸­é—´è¡¨ç¤ºçš„æ•ˆç‡é—®é¢˜ï¼

---

> The detailed syntax and semantics of the representation are defined in the LLVM reference manual [^29].

## 2. PROGRAM REPRESENTATION

è¯¦ç»†çš„è¯­æ³•å‚è€ƒæ‰‹å†Œï¼Œ

[^29]: C. Lattner and V. Adve. LLVM Language Reference Manual. http://llvm.cs.uiuc.edu/docs/LangRef.html. æ³¨ï¼šå·²ç»è¿‡æœŸäº†æœ€æ–°çš„åœ°å€æ˜¯http://releases.llvm.org/1.0/docs/LangRef.html
---

### 2.1 Overview of the LLVM Instruction Set

ABORT: æƒ³çŸ¥é“é™¤äº†SSA[^15]ï¼Œè¿˜æœ‰æ²¡æœ‰å…¶ä»–å½¢å¼ï¼Œè¿™æ ·æ‰èƒ½çŸ¥é“SSAä¸ºä»€ä¹ˆç”¨äºç¼–è¯‘å™¨ä¸­é—´è¡¨ç¤ºçš„ä¼˜åŠ¿å’ŒåŠ£åŠ¿ã€‚

[^15]: [R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. Efficiently computing static single assignment form and the control dependence graph. Trans. Prog. Lang. and Sys., pages 13(4):451â€“490, October 1991.](../../../Essays/IR/1991.Efficiently_Computing_Static_Single_Assignment_Form_and_the_Control_Dependence_Graph.pdf)
---

> The entire LLVM instruction set consists of only 31 opcodes.

ä»…ä»…åªåŒ…å«31æ“ä½œç ï¼ï¼ï¼çœŸç²¾ç®€ï¼

---

> LLVM uses SSA form as its primary code representation, i.e., each virtual register is written in exactly one instruction, and each use of a register is dominated by its definition. Memory locations in LLVM are not in SSA form because many possible locations may be modified at a single store through a pointer, making it difficult to construct a reasonably compact, explicit SSA code representation for such locations.

è¿™é‡Œæåˆ°äº†è®¿å­˜æ²¡æœ‰ç”¨SSAï¼Œè¿™å°±å¾ˆæœ‰æ„æ€äº†ï¼Œèƒ½å¤Ÿåœ¨LLVMé‡Œæ¯”è¾ƒSSAå’ŒéSSAçš„åŒºåˆ«ï¼Œæœ‰å¿…è¦å¥½å¥½çœ‹ä¸€çœ‹è¿™ä¸€éƒ¨åˆ†ï¼

---

> SSA form provides a compact def-use graph that simplifies many dataflow optimizations and enables fast, flow-insensitive algorithms to achieve many of the benefits of flow-sensitive algorithms without expensive dataflow analysis. Non-loop transformations in SSA form are further simplified because they do not encounter anti- or output dependences on SSA registers. Non-memory transformations are also greatly simplified because (unrelated to SSA) registers cannot have aliases.

æ„Ÿè§‰è¿™é‡Œæ¯ä¸€å¥è¯éƒ½æ˜¯ä¸€ä¸ªç ”ç©¶æ–¹å‘ï¼Œæ‰€ä»¥æ˜¯ä¸æ˜¯æœ‰å¿…è¦å»æŸ¥ä¸€ä¸‹è¿™äº›æˆ‘ç›®å‰è¿˜ä¸æ‡‚çš„å†…å®¹ï¼Ÿï¼ˆæ„Ÿè§‰æœ‰å¾ˆå¤šä¸œè¥¿åœ¨ç›®å‰çœ‹æ¥æ˜¯ç†æ‰€åº”å½“çš„å§ï¼‰

### 2.2 Language-independent Type Information, Case, and GetElementPtr

> Every SSA register and explicit memory object has an associated type, and all operations obey strict type rules.

åœ¨æˆ‘çœ‹æ¥å°±æ˜¯å°†å¼±ç±»å‹çš„ç¼–ç¨‹è¯­è¨€ï¼ˆæ¯”å¦‚pythonï¼Œå°½ç®¡é‚£ä¸ªæ—¶å€™è¿˜ä¸æ”¯æŒpythonï¼Œä½†LLVMæ˜¯æœ‰é‡å¿ƒæ”¯æŒå°½å¯èƒ½å¤šçš„ç¼–ç¨‹è¯­è¨€å˜›ï¼›åœ¨æ¯”å¦‚è¯´cé‡Œå…è®¸ç±»å‹è½¬æ¢ï¼‰å°½é‡è½¬å˜ä¸ºå¼ºç±»å‹çš„ç¼–ç¨‹è¯­è¨€ã€‚

---

> This type information enables a broad class of high-level transformations on low-level code (for example, see Section 4.1.1).

DONE: å»çœ‹çœ‹4.1.1èŠ‚ï¼Œè¿™æ ·çš„ç±»å‹ç³»ç»Ÿå¦‚ä½•æ”¯æŒåœ¨ä½å±‚æ¬¡è¯­è¨€ä¸Šå¯¹é«˜å±‚æ¬¡è¯­è¨€è¿›è¡Œå˜æ¢ã€‚æ–‡ç« é‡Œå†™çš„ä»€ä¹ˆä¸œè¥¿ï¼Ÿ

---

> The LLVM type system includes source-language-indep endent primitive types with predefined sizes (void, bool, signed/unsigned integers from 8 to 64 bits, and single- and double-precision floating-point types). ... LLVM also includes (only) four derived types: pointers, arrays, structures, and functions. We believe that most high-level language data types are eventually represented using some combination of these four types in terms of their operational behavior. For example, C++ classes with inheritance are implemented using structures, functions, and arrays of function pointers, as described in Section 4.1.2.

4ç§åŸºæœ¬ç±»å‹ï¼Œ

* void
* bool
* signed/unsigned integers from 8 to 64 bits
* single-/double-precision floating-point

4ç§è¡ç”Ÿç±»å‹ï¼Œ

* pointers
* arrays
* structures
* functions

LLVMçš„è®¾è®¡è€…è®¤ä¸ºå…¶ä»–å¤æ‚çš„ç±»å‹çš†å¯ä»¥åˆè¿™äº›ç±»å‹ç»„æˆã€‚

DONE: è¯¦ç»†é˜…è¯»4.1.2èŠ‚äº†è§£LLVMæä¾›çš„ç±»å‹å¦‚ä½•ç»„æˆå¤æ‚çš„ç±»å‹ã€‚æ–‡ç« é‡Œçš„å†™çš„æ˜¯ä»€ä¹ˆä¸œè¥¿ï¼Ÿ

### 2.3 Explicit Memory Allocation and Unified Memory Model

> In LLVM, all addressable objects (â€œlvaluesâ€) are explicitly allocated.

åº”è¯¥æ˜¯å·¦å€¼çš„æ„æ€å§ã€‚å·¦å€¼å…¨éƒ¨éƒ½éœ€è¦æ˜¾å¼çš„åˆ†é…ç©ºé—´ã€‚

### 2.4 Function Calls and Exception Handling

